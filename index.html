<!--  
BAi 2 HTTP protocol
La cach thuc website truyen tai tren internet,
Viec dau tien la trinh duyet gui di mot yeu cau tới máy chủ Data center, luu trực tiếp trên máy chủ, dựa vô URL nó biết nên trả về cái gì, sau đó nó gửi lại suorce code, trình duyệt đọc source code và hiển thị cho ta thấy
chọn inspect chọn tab network , bấm nút ALL, rồi f5 ta thấy trong bản hiển thị đi rất nhiều yêu cầu, ta thấy đầu tiên nó hiển thị tên miền trang web, có tab General thông tin chung,
gửi đi URL, gửi đi phương thức Request method: Get để lấy dữ liệu về, state Code tình trạng thành công hay thất bại, đầu 200 là thành công, 300 là không thay đổi hoặc chuyển hướng, 400 là lỗi
Remote Address tức địa chỉ máy chủ đang được đặt 172.67.162.2:443 sau : là port là 443 tức địa chỉ ip là tên con đường còn port là số nhà là 443.
khi gửi thông tin đi, thì ta hiểu nó nằm ở mục Resquest header, nó sẽ gửi đi, sau đó máy chủ trả về ở mục response Headers
Tab Headers là thông tin gửi đi, gửi về, tức nó là thông tin bên ngoài bì thư,
con thông tin bên trong nằm ở mục Response, đồn thời response heacers có dữ liệu, nhận lại mã Html, dạng raw data, ở dạng chuỗi, trình duyệt đọc mã và chạy ra trình duyệt
Viết tắt từ Hypertext transfer protocol, phương thức  truyền tải siêu  văn bản: với get là lấy dữ liệu, post để gửi dữ liệu đi, 
http response: lúc này ta thấy nó nhận về suorce code, sau đó trình duyệt biên dịch đi, sau phần header thì có một dòng trống giữa header và body  xem http wiki, dể hiểu rõ hơn, tiếp đó 
load lần 1 
1XX nhận thông tin, tức yêu cầu đã được nhận và tiến trình đang tiếp tục
100 (Continue)
Máy chủ trả về mã này để chỉ ra rằng nó đã nhận được một phần đầu tiên của một yêu cầu và được chờ đợi cho phần còn lại.

101 (Switching protocols)
Bên yêu cầu đã yêu cầu các máy chủ để chuyển đổi và máy chủ được thừa nhận rằng nó sẽ làm như vậy
2xx thành công tức hoạt động được nhận, được hiểu một cách thành công
2xx: Thành công
Nó nghĩa là hoạt động đã được nhận, được hiểu, và được chấp nhận một cách thành công.

200 (Successful)
Các máy chủ xử lý yêu cầu thành công

201 (Created)
Yêu cầu đã thành công và các máy chủ tạo ra một nguồn tài nguyên mới.

202 (Accepted)
Máy chủ đã chấp nhận yêu cầu, nhưng vẫn chưa xử lý nó

203 (Non-authoritative information)
Máy chủ xử lý yêu cầu thành công, nhưng đang quay trở lại các thông tin mà có thể là từ một nguồn khác.

204 (No content)
Các máy chủ xử lý yêu cầu thành công, nhưng không trả lại bất kỳ nội dung nào

205 (Reset content)
Các máy chủ proccessed yêu cầu thành công, nhưng không trả lại bất kỳ nội dung. Không giống như một phản ứng 204, phản ứng này đòi hỏi người yêu cầu thiết lập lại xem tài liệu

206 (Partial content)
Các máy chủ xử lý thành công một phần của một yêu cầu

3xx: Sự điều hướng lại
Nó nghĩa là hoạt động phải được thực hiện để hoàn thành yêu cầu.

301 (Moved permanently)
Các trang web yêu cầu đã bị di chuyển vĩnh viễn tới URL mới

302 (Moved temporarily)
Trang được yêu cầu đã di chuyển tạm thời tới một URL mới

304 (Not modified)
Các trang yêu cầu đã không được sửa đổi kể từ khi yêu cầu cuối cùng. Khi máy chủ trả về phản hồi này, nó không trả lại các nội dung của trang.

4xx: Lỗi Client
Nó nghĩa là yêu cầu chứa cú pháp không chính xác hoặc không được thực hiện

400 (Bad request)
Các máy chủ không hiểu được yêu cầu.

401 (Not authorized)
Đề nghị yêu cầu xác thực. Máy chủ có thể trả về phản hồi này yêu cầu xác thực đăng nhập tài khoản và mật khẩu (thông thường máy chủ trả về phản hồi này nếu client gửi request một trang đăng nhập)

403 (Forbidden)
Máy chủ từ chối yêu cầu.(thông thường nếu đăng nhập không thành công máy chủ sẽ trả về mã lỗi này)

404 (Not found)
Máy chủ không thể tìm thấy trang yêu cầu. Ví dụ, máy chủ thường trả về mã này nếu có 1 yêu cầu tới một trang không tồn tại trên máy chủ.

405 (Method not allowed)
Phương thức được xác định trong yêu cầu là không được cho phép.

406 (Not acceptable)
Server chỉ có thể tạo một phản hồi mà không được chấp nhận bởi Client.

407 (Proxy authentication required)
Yêu cầu client phải xác thực sử dụng một proxy. Khi máy chủ trả về phản hồi này, nó cũng chỉ ra proxy mà người yêu cầu phải sử dụng.

408 (Request timeout)
Request tốn thời gian dài hơn thời gian Server phản hồi

409 (Conflict)
Các máy chủ gặp phải một cuộc xung đột thực hiện yêu cầu. Các máy chủ phải bao gồm thông tin về các cuộc xung đột trong các phản ứng. Máy chủ có thể trả về mã này để đáp ứng với yêu cầu PUT xung đột với yêu cầu trước đó, cùng với một danh sách các sự khác biệt giữa các yêu cầu.

410 (Gone)
Các máy chủ trả về phản hồi này khi các nguồn tài nguyên yêu cầu đã bị loại bỏ vĩnh viễn. Nó tương tự như một 404 (Không tìm thấy) mã, nhưng đôi khi được sử dụng ở vị trí của một 404 cho nguồn lực được sử dụng để tồn tại nhưng không còn làm. Nếu tài nguyên đã di chuyển vĩnh viễn, bạn nên sử dụng một 301 để xác định vị trí mới của tài nguyên.

411 (Length required)
Content-Length không được xác định rõ. Server sẽ không chấp nhận yêu cầu mà không có nó

412 (Precondition failed)
Các máy chủ không đáp ứng một trong các điều kiện tiên quyết mà người yêu cầu đưa vào yêu cầu.

413 (Request entity too large)
Máy chủ không thể xử lý yêu cầu bởi vì nó là quá lớn đối với các máy chủ để xử lý.

414 (Requested URI is too long)
URI yêu cầu (thường là một URL) là quá dài đối với máy chủ để xử lý.

416 (Requested range not satisfiable)
Máy chủ trả về mã trạng thái này nếu yêu cầu cho một phạm vi không có sẵn cho trang.

417 (Expectation failed)
Máy chủ không thể đáp ứng yêu cầu của các trường yêu cầu, tiêu đề mong đợi.

5xx: Lỗi Server
Nó nghĩa là Server thất bại với việc thực hiện một yêu cầu nhìn như có vẻ khả thi.

500 (Internal server error)
Các máy chủ gặp lỗi và không thể thực hiện yêu cầu.

501 (Not implemented)
Các máy chủ không có các chức năng để thực hiện yêu cầu. Ví dụ, máy chủ có thể trả về mã này khi nó không nhận ra phương thức yêu cầu.

502 (Bad gateway)
Các máy chủ đã hoạt động như một gateway hoặc proxy và nhận được một phản ứng không hợp lệ từ máy chủ ngược.

503 (Service unavailable)
Máy chủ hiện không có sẵn (vì nó bị quá tải hoặc xuống để bảo trì). Nói chung, đây là một trạng thái tạm thời.

504 (Gateway timeout)
Các máy chủ đã hoạt động như một gateway hoặc proxy và đã không nhận được yêu cầu kịp thời từ máy chủ ngược.

505 (HTTP version not supported)
Các máy chủ không hỗ trợ phiên bản giao thức HTTP được sử dụng trong yêu cầu.

Sau đây là danh sách tất cả các mã trạng thái HTTP được liệt kê theo tài liệu giao thức HTTP của trang w3c

BAi 3: SSR và CSR:
 SSR Server side redering (render"đang xuất")
 tCơ chế server-side rendering đã được dùng từ thuở xưa ơi là xưa. Gọi nó là server-side rendering là vì phần lớn logic sẽ được xử lý ở server:

Khi người dùng vào một trang web, trình duyệt sẽ gửi GET request tới web server
Web server sẽ nhận request, đọc dữ liệu từ database.
Web server sẽ render HTML, trả về cho browser để hiển thị cho người dùng
Một số tính chất của cơ chế server side rendering:

Logic từ đơn giản (validation, đọc dữ liệu) cho đến phức tạp (phân quyền, thanh toán) đều nằm ở phía server
Logic để routing – chuyển trang nằm ở server
Logic để render – hiển thị trang web cũng nằm ở server nốt
Ưu và nhược điểm của Server Side Rendering
Ra đời đã lâu, server side rendering đã được sử dụng, cải tiến rất nhiều (Caching, CDN). Những ưu điểm của cơ chế này:

Initial load nhanh, dễ otpimize, vì toàn bộ dữ liệu đã được xử lý ở server. Client chỉ việc hiển thị.
Các web framework từ xưa đến nay đều hỗ trợ cơ chế này
Dễ hiểu và dễ code hơn. Developer chỉ cần code 1 project web là được, không cần phải tách ra front-end và back-end
SEO tốt vì khi bot của Google, Bing vào web sẽ thấy toàn bộ dữ liệu dưới dạng HTML.
Chạy được trên phần lớn mọi trình duyệt, kể cả disable JavaScript vẫn chạy tốt

Thế nhưng, bên cạnh đó, server side rendering cũng có một số nhược điểm:
Mỗi lần người dùng chuyển trang là site phải load lại nhiều lần, gây khó chịu
Nặng server vì server phải xử lý nhiều logic và dữ liệu. Có thể sử dụng caching để giảm tải.
Tốn băng thông vì server phải gửi nhiều dữ liệu thừa và trùng  (HTML, header, footer). Có thể sử dụng CDN để giảm tải.
Tương tác không tốt như Client Side rendering vì trang phải refresh, load lại nhiều lần.
Cơ chế server side rendering vẫn còn được sử dụng ở rất rất nhiều site. Do vậy, chỉ cần hiểu rõ và nắm vững cơ chế này là bạn đã có thể làm một trang web đầy đủ tính năng rồi.

Các trang web sử dụng cơ chế này:

Toàn bộ những trang web được build từ CMS như Joomla, WordPress.
Các trang web bán hàng, web tin tức: Thegioididong, Vnexpress, Zing News
Các web đọc truyện và forum: Webtretho, vozforum


 CSR Client side redering 
 Thế rồi, ở những năm 2010, với sự phát triển của JavaScript và AJAX, cơ chế client-side rendering bắt đầu được sử dụng.

Developer bắt đầu build ứng dụng dưới dạng SPA – Single Page Application. Ứng dụng nằm trong 1 page duy nhất nên được gọi là Single Page Application.

Client Side Rendering tức là việc render HTML, CSS sẽ được thực hiện ở client (Tức JavaScript ở trình duyệt)
So với Server Side Rendering (SSR) đã nhắc trong phần 1, Client Side Rendering (CSR) có những đặc điểm sau:

Những logic đơn giản (validation, đọc dữ liệu, sorting, filtering) nằm ở client side
Logic để routing (chuyển trang), render (hiển thị) dữ liệu thì 96.69% là nằm ở client side
Logic phức tạp (thanh toán, phân quyền) hoặc cần xử lý nhiều (data processing, report) vẫn nằm ở server side.
Ưu nhược điểm của Client-side rendering
Ra mắt sau nên Client Side Rendering giải quyết được một số vấn đề của server side rendering:

Page chỉ cần load một lần duy nhất. Khi user chuyển trang hoặc thêm dữ liệu, JavaScript sẽ lấy và gửi dữ liệu từ server qua AJAX. User có thể thấy dữ liệu mới mà không cần chuyển trang.
Chuyển logic sang client nên giảm tải được một phần cho server.
Giảm được băng thông do chỉ cần lấy JSON và dữ liệu cần thiết, thay vì phải lấy toàn bộ trang
Với các ứng dụng cần tương tác nhiều, SPA hoạt động mượt mà hơn vì code chạy trên browser, không cần load đi loại lại nhiều
Tất nhiên là client side rendering cũng có một số nhược điểm riêng:

Initial load sẽ chậm hơn nếu không biết optimize. Lý do là broser phải tải toàn bộ JavaScript về (khá nặng), parse và chạy JS, gọi API để lấy dữ liệu từ server (chậm), sau đó render dữ liệu
Đòi hỏi project phải chia làm 2 phần riêng là back-end (REST api) và front-end nên khó code hơn
Không chạy được nếu JavaScript bị disable, hoặc ở các trình duyệt cũ không nhận JavaScript ES6 (Có thể dùng transpiler và polyfill nhưng sẽ làm tăng kích cỡ file js)
SEO không tốt bằng Server Side Rendering (Do bot crawl không đọc được dữ liệu). Để giải quyết, ta phải kết hợp thêm SSR (Bot mới của Google đọc được client-side rendering rồi).
Nếu client sử dụng mobile, device yếu thì khi load sẽ bị chậm
Các website sử dụng Client-Side Rendering
Vì Client-side rendering rất phù hợp cho những ứng dụng cần tương tác nhiều, hầu hết web của các công ty công nghệ, công ty startup đều đùng cơ chế này:

Facebook (React)
Instagram (React)
Netflix (React)
Dropbox (React)
AirBnb (React)
Trello (Angular)
Paypal (Angular + React)
Xiaomi (VueJS)
Alibabe (VueJS)
Gitlab (VueJS)
Nói chung, client side rendering còn khá mới mẻ nên vẫn còn một số vấn đề nhỏ chưa được giải quyết tốt (tối ưu tốc độ initial load, giảm kích cỡ file JavaScript của app).

Một điều mình không nhắc đến trong bài là đôi khi các website sẽ kết hợp cả server-side rending lẫn client side rendering. Ví dụ server sẽ tải trước một số dữ liệu dưới dạng JSON cho client, hoặc server sẽ render HTML khi gặp bot đễ hỗ trợ crawl tốt hơn.

Bản thân các thư viện client-side rendering như React, VueJS cũng đều hỗ trợ server rendering (React có react-dom/server, VueJS có Nuxt). Nếu có hứng thú, các bạn có thể tự tìm hiểu thêm nhé!

 SSR thường sử dụng trang báo chí, chẳng hạn tin tức mỹ, bôi đen dòng chữ bất kỳ  sau đó chọn  view pace source, thì lúc này ta thấy nó rất nhiều source code, rất nhiều code, còn ngược lại
 đối với CSR thì khi view page source nó có một trang hoặc 2 à, nó nằm hết bên html bên kia của ta.
 Có những thứ nó kết hợp cả 2 CSR, SSR. Tức cài nào cần sale thì nó sẽ chạy SSR,
 Sử dụng SSR để tăng tóc độ tìm kiếm.
 SSR tốt cho sale, vì nó chứa hết mã và code rồi, tốc độ nhanh hơn, mỗi lần thao tác nó sẽ tải lại toàn bộ trang, ta thấy trang nó xoay. Thời gian phát triển ứng dụng đối với SSR ngắn hạn thì nhah hơn
 CSR  việc đầu tiên sẽ đọc file JS, đợi JS thực thi rồi mới app cái file rồ, mỗi lần thao tác nó không cần tải lại, chỉ tải thêm trang mới thôi.

 Bai 4 Node.Js là một javascript chạy dựa trên chrome V* javascript engines( tức lõi, động cơ) trình thông dịch chạy trên trình duyệt chrome, 
 kiểm tra cài thành công hay chưa, bấm terminal( cửa sổ thao tác sdongf lệnh), gõ node -v, sẽ thấy phiên bản của nó. Cài kèm theo quản lý thư viện quản lý, gõ npm -v, nó ra phiên bản thì ta đã cài xong rồi
    Tạo ra trang block đầu tiên, npm init, có nghĩa là tạo ra một gói mới, npm là gói, tạo github, copy link github của ta khai báo, keyword, những từ khóa nó nói về gói, sau đó tiếp tục ròi gõ yes, sau đó nó tạo ra file package.json,
     ta tạo ra filetrung với tên main: mà ta thiết lập trước đó, ở đây mặc định là index.js, 
     Cài express, gõ npm express, trang quản lý dự án mã nguồn mở, với câu lệnh ta search được là npm install express
     lúc này ta thầy file pakage.json xuất hiện thêm  
     "dependencies": {
    "express": "^4.17.1"
    dependencies tức là phụ thuộc, tức chuognw trình của ta phụ thuộc và express quản lý này thì mới chạy được.
    Package-lock.json, túc có nghĩa là express nó còn bị phụ thuộc vào những cái khác, tức pakage quản lý phụ thuộc của express. còn express thì quản lý phụ thuộc của nó 
    Trang chủ framework expressjs.com, đọc phần getting started:
    Bước 1 import thư viện
    Qua bên index.js
    ctrl C để thoát server
    BAi 7 Nodemon dùng để lắng nghe sự thay đổi, gõ npm tìm kiếm nodemon,  gõ npm install --save-dev nodemon nó sẽ nằm trong dependencies, cách sử dụng
    node index.js, bây giờ ta chạy ta không gõ kiểu này, vô package vô script, dưới dó tạo thêm phần
    "scripts": {
    "start" : "nodemon index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  khi chạy thay vì gõ nodemon index.js thì gõ npm start thì nó chạy
  bây giờ ta thay đổi '/tin-tuc' rồi qua bên trang web ta f5 cái là nó cập nhật, ta không cần phải ctrl c để thoát ra rồi khởi chạy lại nữa
  ngoài ra nó còn cung cấp inspect nữa, qua bên
  "scripts": {
    "start" : "nodemon --inspect index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
   giúp hỗ trợ debug gỡ lỗi: 
   Bài 7 add github: mở ra một cửa sổ terminal mới gõ git init, sau đó tạo ra một file là .gitignore  trong file đó ta gõ 
   .vscode 
   node_modules
   để nó bỏ đi 2 file nặng đó để đẩy lên code
   sau đó gõ git add .
   git commit -m "initial commit"
   gõ là 2 cái mà trên github cho khi ta tạo thư mục mới NodeJS_blog á, rồi dưới phần or create.... nó có á
   git remote add origin https://github.com/VuLocDuong97/NodeJS_blog.git
git push -u origin main

-->